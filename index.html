<!DOCTYPE html>
<html>
  <head>
    <title>gloom</title>
  </head>
  <body style="background-color: #222222">
    <canvas id="viewport"></canvas>
    <script>
      (async () => {
        const fbWidth = 640;
        const fbHeight = 480;

        // remove margin from body to make canvas fullscreen
        document.body.style.margin = "0";
        
        const textDecoder = new TextDecoder("utf-8");

        const canvas = document.getElementById("viewport");
        const ctx = canvas.getContext("2d");
        // set transform origin to top-left corner
        canvas.style.transformOrigin = "0 0";
        canvas.style.imageRendering = "crisp-edges";
        canvas.width = fbWidth;
        canvas.height = fbHeight;

        let memory = null;

        // void write(int fd, const char* str, u32 len);
        function write(fd, p, l) {
          const s = textDecoder.decode(memory.buffer.slice(p, p + l));
          switch (fd) {
            case 1:
              console.log(s);
              break;
            case 2:
              console.error(s);
              break;
            default:
              break;
          }
        }

        function pointerIsLocked() {
          return document.pointerLockElement === canvas;
        }

        // void pointer_lock(void);
        function pointer_lock() {
          if (pointerIsLocked()) {
            return;
          }

          const promise = canvas.requestPointerLock({ unadjustedMovement: true });

          if (!promise) {
            console.warn("disabling mouse acceleration is not supported");
            canvas.requestPointerLock();
            return;
          }

          promise
            .then(() => {
              console.assert(pointerIsLocked());
              console.log("pointer locked");
            })
            .catch(error => {
              if (error.name === "NotSupportedError") {
                console.warn("disabling mouse acceleration is not supported");
                canvas.requestPointerLock();
              } else {
                console.error("could not lock pointer: " + error.name);
              }
            });
        }

        // void pointer_release(void);
        function pointer_release() {
          document.exitPointerLock();
        }

        const importObject = {
          env: {
            write,
            pointer_lock,
            pointer_release,
          },
        };

        const obj = await WebAssembly.instantiateStreaming(fetch("/gloom.wasm"), importObject);
        const instance = obj.instance;

        memory = instance.exports.memory;

        const fbSize = fbWidth * fbHeight * 4;
        const zBufSize = fbWidth * 4;
        memory.grow(Math.ceil((fbSize + zBufSize) / (64 * 1024)));
        
        const fbView = new Uint8ClampedArray(memory.buffer, instance.exports.__heap_base, fbSize);
        const fb = new ImageData(fbView, fbWidth, fbHeight);

        // init game
        instance.exports.init(fbWidth, fbHeight);

        function updateViewportSize() {
          // shamelessly stolen from
          // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#scaling_canvas_using_css_transforms
          const xScale = window.innerWidth / canvas.width;
          const yScale = window.innerHeight / canvas.height;
          const scaleToFit = Math.min(xScale, yScale);
          canvas.style.transform = `scale(${scaleToFit})`;
        }

        function processKeyEvent(event) {
          instance.exports.key_event(event.keyCode, event.key.charCodeAt(0), event.type === "keydown");
        }

        window.addEventListener("resize", updateViewportSize);
        window.addEventListener("keydown", processKeyEvent);
        window.addEventListener("keyup", processKeyEvent);
        window.addEventListener("pointerlockchange", () => instance.exports.set_pointer_locked(pointerIsLocked()));
        canvas.addEventListener("click", e => instance.exports.mouse_click());
        canvas.addEventListener("mousemove", e => instance.exports.mouse_moved(e.layerX, e.layerY, e.movementX, e.movementY));
        updateViewportSize();

        let prevTimestamp;

        function tick(timestamp) {
          const delta = (timestamp - prevTimestamp) / 1000;
          instance.exports.tick(delta);
          ctx.putImageData(fb, 0, 0);
          prevTimestamp = timestamp;
          window.requestAnimationFrame(tick);
        }

        window.requestAnimationFrame((timestamp) => {
          prevTimestamp = timestamp;
          window.requestAnimationFrame(tick);
        });
      })();
    </script>
  </body>
</html>
